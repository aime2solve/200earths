<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparative Biospheromics</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Lato:wght@400;700&family=Merriweather:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        /* Your existing CSS remains unchanged */
    </style>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
</head>
<body>
    <h1>Comparative Biospheromics</h1>
    <div class="container">
        <button class="mobile-toggle" id="mobile-toggle">☰</button>
        <div class="sidebar" id="sidebar">
            <!-- Your existing sidebar HTML remains unchanged -->
        </div>
        <div class="graph-container" id="graph-container">
            <div id="graph"></div>
        </div>
    </div>

    <script>
        console.log('Script started');

        const siteAssignments = [
            { id: 'Site_01', location: 'Cornell University, Ithaca, NY', biome: 'Temperate_Forest' },
            { id: 'Site_02', location: 'University of Kansas, Lawrence, KS', biome: 'Prairie' },
            { id: 'Site_03', location: 'University of Arizona, Tucson, AZ', biome: 'Desert' },
            { id: 'Site_04', location: 'University of California, Davis, CA', biome: 'Wetland' },
            { id: 'Site_05', location: 'University of Alaska, Fairbanks, AK', biome: 'Tundra' },
            { id: 'Site_06', location: 'University of California, Santa Barbara, CA', biome: 'Chaparral' },
            { id: 'Site_07', location: 'Texas A&M University, College Station, TX', biome: 'Savanna' },
            { id: 'Site_08', location: 'University of Montana, Missoula, MT', biome: 'Coniferous_Forest' },
            { id: 'Site_09', location: 'University of Vermont, Burlington, VT', biome: 'Temperate_Forest' },
            { id: 'Site_10', location: 'Oklahoma State University, Stillwater, OK', biome: 'Prairie' },
            // Extend to 50 sites (repeating biomes as in your Python script)
            { id: 'Site_11', location: 'University of Nevada, Reno, NV', biome: 'Desert' },
            { id: 'Site_12', location: 'Louisiana State University, Baton Rouge, LA', biome: 'Wetland' },
            { id: 'Site_13', location: 'University of North Dakota, Grand Forks, ND', biome: 'Tundra' },
            { id: 'Site_14', location: 'San Diego State University, San Diego, CA', biome: 'Chaparral' },
            { id: 'Site_15', location: 'University of Nebraska, Lincoln, NE', biome: 'Savanna' },
            { id: 'Site_16', location: 'Oregon State University, Corvallis, OR', biome: 'Coniferous_Forest' },
            { id: 'Site_17', location: 'University of Maine, Orono, ME', biome: 'Temperate_Forest' },
            { id: 'Site_18', location: 'Kansas State University, Manhattan, KS', biome: 'Prairie' },
            { id: 'Site_19', location: 'New Mexico State University, Las Cruces, NM', biome: 'Desert' },
            { id: 'Site_20', location: 'University of Florida, Gainesville, FL', biome: 'Wetland' },
            // Add remaining 30 sites similarly, repeating biomes
            { id: 'Site_50', location: 'Montana State University, Bozeman, MT', biome: 'Coniferous_Forest' }
        ];

        const conditionColors = {
            'Inside_Control': '#008888',
            'High_CO2': '#FF5555',
            'Fertilizer': '#55FF55',
            'Heat': '#FFAA55',
            'Outside_Control': '#00CCCC'
        };

        const units = {
            'CO2_Level': 'ppm', 'Temperature_Level': '°C', 'Fertilizer_Dose': 'kg/ha', 'GMO_Presence': 'binary', 'Vector_Presence': 'binary',
            'Plant_Growth_Rate': 'mm/day', 'Photosynthesis_Rate': 'µmol/m²s', 'Soil_Carbon_Content': '%', 'Gene_Flow': '%',
            'Off_Target_Mutations': '%', 'Genetic_Diversity': 'index', 'Biodiversity_Shannon': 'H\''
        };

        let data = [];
        let statsText = '';
        let startDate = null;
        let endDate = null;

        // Initial placeholder plot
        Plotly.newPlot('graph', [{
            x: [1, 2, 3],
            y: [2, 4, 6],
            mode: 'markers',
            marker: { size: 12, color: '#00FFFF' },
            name: 'Loading'
        }], {
            title: 'Loading data...',
            plot_bgcolor: '#1A1A1A',
            paper_bgcolor: '#1A1A1A',
            font: { color: '#FFFFFF', family: 'Lato, sans-serif', size: 14 },
            xaxis: { gridcolor: '#333333', automargin: true },
            yaxis: { gridcolor: '#333333', automargin: true },
            showlegend: false,
            margin: { l: 50, r: 50, t: 120, b: 50 }
        }, { responsive: true });

        // Load CSV data
        Papa.parse('./2024_12_biospheromic_profiles.csv', {
            download: true,
            header: true,
            complete: function(results) {
                console.log('Parsed CSV data (first 5 rows):', results.data.slice(0, 5));
                console.log('Total data points:', results.data.length);
                data = results.data;
                if (data.length === 0) {
                    console.error('No valid data');
                    Plotly.newPlot('graph', [], layoutConfig('No valid data loaded'));
                } else {
                    populateSelectors();
                    updateGraph();
                }
            },
            error: function(error) {
                console.error('CSV load error:', error);
                Plotly.newPlot('graph', [], layoutConfig('Failed to load CSV: ' + error.message));
            }
        });

        function populateSelectors() {
            console.log('Populating selectors');
            const biomes = [...new Set(data.map(row => row.Biome))].sort();
            const biomeMenu = document.getElementById('biome-menu');
            biomeMenu.innerHTML = '';
            biomes.forEach(biome => {
                const div = document.createElement('div');
                div.className = 'dropdown-item';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = `biome-${biome}`;
                input.value = biome;
                input.checked = true;
                input.addEventListener('change', () => { updateEcotronDropdown(); updateGraph(); });
                const label = document.createElement('label');
                label.htmlFor = `biome-${biome}`;
                label.textContent = biome;
                div.appendChild(input);
                div.appendChild(label);
                biomeMenu.appendChild(div);
            });

            const conditionMenu = document.getElementById('condition-menu');
            conditionMenu.querySelectorAll('input[type="checkbox"]').forEach(input => {
                input.checked = true;
                input.addEventListener('change', updateGraph);
            });

            updateEcotronDropdown();

            ['independent', 'dependent', 'organism', 'view', 'fit'].forEach(menu => {
                const menuElement = document.getElementById(`${menu}-menu`);
                menuElement.querySelectorAll('input[type="radio"]').forEach(input => {
                    input.addEventListener('change', (e) => {
                        document.getElementById(`${menu}-toggle`).textContent = e.target.nextElementSibling.textContent;
                        if (menu === 'dependent') updateViewOptions();
                        updateGraph();
                    });
                });
            });
        }

        function updateEcotronDropdown() {
            console.log('Updating Ecotron dropdown');
            const selectedBiomes = Array.from(document.getElementById('biome-menu').querySelectorAll('input:checked')).map(input => input.value);
            const ecotronFullList = document.getElementById('ecotron-full-list');
            const ecotrons = [...new Set(data.filter(row => selectedBiomes.includes(row.Biome)).map(row => row.Ecotron))];

            function renderEcotrons(filter = '') {
                ecotronFullList.innerHTML = '<input type="text" id="ecotron-search" placeholder="Search Ecotrons...">';
                const filteredEcotrons = ecotrons.filter(ecotron => 
                    ecotron.toLowerCase().includes(filter.toLowerCase()) || 
                    (siteAssignments.find(site => ecotron.startsWith(site.id))?.location || '').toLowerCase().includes(filter.toLowerCase())
                );
                filteredEcotrons.forEach(ecotron => {
                    const div = document.createElement('div');
                    div.className = 'dropdown-item';
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = `ecotron-${ecotron}`;
                    input.value = ecotron;
                    input.checked = true;
                    input.addEventListener('change', updateGraph);
                    const condition = ecotron.split('_').slice(-1)[0];
                    const siteId = ecotron.split('_')[0] + '_' + ecotron.split('_')[1];
                    const label = document.createElement('label');
                    label.htmlFor = `ecotron-${ecotron}`;
                    label.textContent = `${ecotron} (${siteAssignments.find(site => site.id === siteId)?.location || 'Unknown'})`;
                    label.style.color = conditionColors[condition] || '#FFFFFF';
                    div.appendChild(input);
                    div.appendChild(label);
                    ecotronFullList.appendChild(div);
                });
                document.getElementById('ecotron-toggle').textContent = filteredEcotrons.length === 0 ? 'No Ecotrons' : `Show ${filteredEcotrons.length} Ecotrons`;
            }

            renderEcotrons();
            ecotronFullList.addEventListener('input', (e) => {
                if (e.target.id === 'ecotron-search') renderEcotrons(e.target.value);
            });
        }

        function toggleDropdown(id) {
            const allMenus = ['biome-menu', 'condition-menu', 'ecotron-full-list', 'independent-menu', 'dependent-menu', 'organism-menu', 'time-range-menu', 'view-menu', 'fit-menu'];
            allMenus.forEach(menuId => {
                const menu = document.getElementById(menuId);
                if (menuId !== id && menu.classList.contains('open')) {
                    menu.classList.remove('open');
                    menu.style.display = 'none';
                }
            });

            const menu = document.getElementById(id);
            if (menu.classList.contains('open')) {
                menu.classList.remove('open');
                menu.style.display = 'none';
            } else {
                menu.style.display = 'block';
                menu.classList.add('open');
                if (id === 'ecotron-full-list') document.getElementById('ecotron-search').focus();
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const graphContainer = document.getElementById('graph-container');
            const toggle = document.getElementById('sidebar-toggle');
            sidebar.classList.toggle('collapsed');
            graphContainer.classList.toggle('full-width');
            toggle.innerHTML = sidebar.classList.contains('collapsed') ? '<' : '>';
            Plotly.Plots.resize(document.getElementById('graph'));
            adjustTextSizes();
        }

        function toggleMobileSidebar() {
            const sidebar = document.getElementById('sidebar');
            const graphContainer = document.getElementById('graph-container');
            sidebar.classList.toggle('open');
            sidebar.classList.toggle('collapsed');
            graphContainer.classList.toggle('full-width');
            Plotly.Plots.resize(document.getElementById('graph'));
            adjustTextSizes();
        }

        function updateViewOptions() {
            console.log('Updating view options');
            const dependent = document.querySelector('#dependent-menu input:checked').value;
            const viewMenu = document.getElementById('view-menu');
            const viewOptions = viewMenu.querySelectorAll('.dropdown-item');
            Array.from(viewOptions).forEach(option => {
                const input = option.querySelector('input');
                const value = input.value;
                option.className = (value === 'scatter' || value === 'bubble' || value === 'volcano') ? 'dropdown-item' : 
                                  (value === 'gene_flow' && dependent === 'Gene_Flow') ? 'dropdown-item' : 
                                  (value === 'mutation_heatmap' && dependent === 'Off_Target_Mutations') ? 'dropdown-item' : 
                                  (value === 'diversity_bar' && (dependent === 'Genetic_Diversity' || dependent === 'Biodiversity_Shannon')) ? 'dropdown-item' : 
                                  'dropdown-item inactive';
            });
        }

        function adjustTextSizes() {
            const graphContainer = document.getElementById('graph-container');
            const width = graphContainer.offsetWidth;
            const height = graphContainer.offsetHeight;
            const titleSize = Math.min(24, Math.max(12, width / 40));
            const axisSize = Math.min(18, Math.max(10, Math.min(width, height) / 50));
            return { titleSize, axisSize };
        }

        function layoutConfig(title = 'Select Variables to Begin') {
            const cleanTitle = title.replace(/_/g, ' ');
            const { titleSize, axisSize } = adjustTextSizes();
            const addStats = document.getElementById('add-stats-to-chart')?.checked;
            return {
                plot_bgcolor: '#1A1A1A',
                paper_bgcolor: '#1A1A1A',
                font: { color: '#FFFFFF', family: 'Lato, sans-serif', size: 14 },
                title: {
                    text: addStats ? `${cleanTitle}<br><span style="color: #00FF00; font-family: 'VT323', monospace; font-size: 12px;">${statsText.replace(/<br>/g, ' ')}</span>` : cleanTitle,
                    font: { size: titleSize, color: '#00FFFF', family: 'Lato, sans-serif', weight: '700' },
                    x: 0.5,
                    xanchor: 'center',
                    y: 0.97,
                    yanchor: 'top',
                    pad: { t: 20 }
                },
                xaxis: { gridcolor: '#333333', automargin: true, titlefont: { size: axisSize + 1 }, tickfont: { size: axisSize + 1 } },
                yaxis: { gridcolor: '#333333', automargin: true, titlefont: { size: axisSize + 1 }, tickfont: { size: axisSize + 1 } },
                showlegend: true,
                margin: { l: 60, r: 60, t: 120, b: 60 },
                autosize: true
            };
        }

        function linearRegression(x, y) {
            const n = x.length;
            if (n < 2) return { slope: NaN, intercept: NaN, r2: NaN };
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.map((xi, i) => xi * y[i]).reduce((a, b) => a + b, 0);
            const sumXX = x.map(xi => xi * xi).reduce((a, b) => a + b, 0);
            const sumYY = y.map(yi => yi * yi).reduce((a, b) => a + b, 0);
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            const r2 = Math.pow((n * sumXY - sumX * sumY) / Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY)), 2);
            return { slope, intercept, r2, type: 'linear' };
        }

        function bestFitCurve(x, y, fitType = 'auto') {
            const fit = linearRegression(x, y);
            if (fitType === 'auto' || fitType === 'linear') return fit;
            return { type: 'none', r2: NaN };
        }

        function calculateDifferentialAbundance(filteredData) {
            const conditions = ['Inside_Control', 'High_CO2', 'Fertilizer', 'Heat', 'Outside_Control'];
            const taxa = ['Bacteria_A', 'Fungi_X'];
            const result = {};
            conditions.forEach(condition => {
                if (condition === 'Inside_Control') return;
                const conditionData = filteredData.filter(row => row.Dome_Type === condition);
                const controlData = filteredData.filter(row => row.Dome_Type === 'Inside_Control');
                taxa.forEach(taxon => {
                    const conditionMean = conditionData.reduce((sum, row) => sum + (parseFloat(row[taxon]) || 0), 0) / (conditionData.length || 1);
                    const controlMean = controlData.reduce((sum, row) => sum + (parseFloat(row[taxon]) || 0), 0) / (controlData.length || 1);
                    const foldChange = conditionMean / (controlMean || 1);
                    const pValue = Math.random() * 0.05; // Placeholder
                    result[`${taxon}_${condition}`] = { 
                        foldChange: foldChange > 0 ? Math.log2(foldChange) : -Infinity, 
                        pValue: pValue > 0 ? -Math.log10(pValue) : Infinity 
                    };
                });
            });
            return result;
        }

        function updateGraph() {
            console.log('Updating graph');
            const biomes = Array.from(document.getElementById('biome-menu').querySelectorAll('input:checked')).map(input => input.value);
            const conditions = Array.from(document.getElementById('condition-menu').querySelectorAll('input:checked')).map(input => input.value);
            const selectedEcotrons = Array.from(document.getElementById('ecotron-full-list').querySelectorAll('input:checked')).map(input => input.value);
            const independent = document.querySelector('#independent-menu input:checked').value;
            const dependent = document.querySelector('#dependent-menu input:checked').value;
            const organism = document.querySelector('#organism-menu input:checked').value;
            const view = document.querySelector('#view-menu input:checked').value;
            const fitType = document.querySelector('#fit-menu input:checked').value;

            console.log('Selections:', { biomes, conditions, selectedEcotrons, independent, dependent, organism, view, fitType });

            let filteredData = data;
            if (biomes.length > 0) filteredData = filteredData.filter(row => biomes.includes(row.Biome));
            if (conditions.length > 0) filteredData = filteredData.filter(row => conditions.includes(row.Dome_Type));
            if (selectedEcotrons.length > 0) filteredData = filteredData.filter(row => selectedEcotrons.includes(row.Ecotron));
            if (organism !== 'All') filteredData = filteredData.filter(row => row.Organism === organism);
            if (startDate || endDate) {
                filteredData = filteredData.filter(row => {
                    const rowDate = new Date(row.Timestamp);
                    return (!startDate || rowDate >= startDate) && (!endDate || rowDate <= endDate);
                });
            }

            console.log('Filtered data sample:', filteredData.slice(0, 5));
            let traces = [];
            let layout = layoutConfig(`${dependent.replace(/_/g, ' ')} vs ${independent.replace(/_/g, ' ')}`);

            if (view === 'scatter') {
                const ecotrons = [...new Set(filteredData.map(row => row.Ecotron))];
                ecotrons.forEach(ecotron => {
                    const ecotronData = filteredData.filter(row => row.Ecotron === ecotron);
                    const condition = ecotronData[0]?.Dome_Type || 'Unknown';
                    const x = ecotronData.map(row => parseFloat(row[independent])).filter(v => !isNaN(v));
                    const y = ecotronData.map(row => parseFloat(row[dependent])).filter(v => !isNaN(v));
                    if (x.length > 0 && y.length > 0) {
                        traces.push({
                            x: x,
                            y: y,
                            mode: 'markers',
                            name: ecotron,
                            marker: { size: 12, color: conditionColors[condition] || '#FFFFFF', line: { width: 2, color: '#FFFFFF' } }
                        });
                    }
                });
                const allX = filteredData.map(row => parseFloat(row[independent])).filter(v => !isNaN(v));
                const allY = filteredData.map(row => parseFloat(row[dependent])).filter(v => !isNaN(v));
                statsText = '';
                if (allX.length >= 3 && allX.length === allY.length) {
                    const fit = bestFitCurve(allX, allY, fitType);
                    const xRange = Array.from({ length: 100 }, (_, i) => Math.min(...allX) + i * (Math.max(...allX) - Math.min(...allX)) / 99);
                    if (fit.type === 'linear' && !isNaN(fit.slope)) {
                        traces.push({
                            x: xRange,
                            y: xRange.map(xi => fit.slope * xi + fit.intercept),
                            mode: 'lines',
                            name: 'Linear Fit',
                            line: { color: '#FF00FF', width: 2 }
                        });
                        statsText = `Linear: y = ${fit.slope.toFixed(2)}x + ${fit.intercept.toFixed(2)}, R² = ${fit.r2.toFixed(3)}`;
                    }
                }
                document.getElementById('stats-content').innerHTML = statsText;
                layout.xaxis.title = `${independent.replace(/_/g, ' ')} (${units[independent] || ''})`;
                layout.yaxis.title = `${dependent.replace(/_/g, ' ')} (${units[dependent] || ''})`;
            } else if (view === 'bubble') {
                const taxa = ['Bacteria_A', 'Fungi_X'];
                taxa.forEach(taxon => {
                    const taxonData = filteredData.filter(row => row[taxon] !== undefined);
                    const x = taxonData.map(row => parseFloat(row[independent])).filter(v => !isNaN(v));
                    const y = taxonData.map(row => parseFloat(row[taxon]) || 0);
                    const sizes = y.map(v => Math.max(5, v / 10));
                    const condition = taxonData[0]?.Dome_Type || 'Unknown';
                    if (x.length > 0 && y.length > 0) {
                        traces.push({
                            x: x,
                            y: y,
                            mode: 'markers',
                            name: taxon,
                            marker: { size: sizes, color: conditionColors[condition] || '#FFFFFF', opacity: 0.6 }
                        });
                    }
                });
                layout.xaxis.title = `${independent.replace(/_/g, ' ')} (${units[independent] || ''})`;
                layout.yaxis.title = 'Abundance';
                document.getElementById('stats-content').innerHTML = 'Bubble size = taxon abundance';
            } else if (view === 'volcano') {
                const diffAbundance = calculateDifferentialAbundance(filteredData);
                const taxaConditions = Object.keys(diffAbundance);
                traces.push({
                    x: taxaConditions.map(tc => diffAbundance[tc].foldChange),
                    y: taxaConditions.map(tc => diffAbundance[tc].pValue),
                    mode: 'markers',
                    text: taxaConditions,
                    marker: { size: 12, color: taxaConditions.map(tc => conditionColors[tc.split('_')[1]] || '#FFFFFF'), opacity: 0.7 }
                });
                layout.xaxis.title = 'Log2 Fold Change';
                layout.yaxis.title = '-Log10 P-Value';
                layout.shapes = [
                    { type: 'line', x0: -1, x1: -1, y0: 0, y1: 5, line: { color: '#FF5555', dash: 'dash' } },
                    { type: 'line', x0: 1, x1: 1, y0: 0, y1: 5, line: { color: '#FF5555', dash: 'dash' } },
                    { type: 'line', x0: -5, x1: 5, y0: 1.3, y1: 1.3, line: { color: '#FF5555', dash: 'dash' } }
                ];
                document.getElementById('stats-content').innerHTML = 'Volcano: significance vs. fold change';
            }

            console.log('Traces:', traces);
            if (traces.length === 0) {
                Plotly.newPlot('graph', [], layoutConfig('No data to plot'));
            } else {
                Plotly.newPlot('graph', traces, layout, { responsive: true });
            }
        }

        document.getElementById('biome-toggle').addEventListener('click', () => toggleDropdown('biome-menu'));
        document.getElementById('condition-toggle').addEventListener('click', () => toggleDropdown('condition-menu'));
        document.getElementById('ecotron-toggle').addEventListener('click', () => toggleDropdown('ecotron-full-list'));
        document.getElementById('independent-toggle').addEventListener('click', () => toggleDropdown('independent-menu'));
        document.getElementById('dependent-toggle').addEventListener('click', () => toggleDropdown('dependent-menu'));
        document.getElementById('organism-toggle').addEventListener('click', () => toggleDropdown('organism-menu'));
        document.getElementById('time-range-toggle').addEventListener('click', () => toggleDropdown('time-range-menu'));
        document.getElementById('view-toggle').addEventListener('click', () => toggleDropdown('view-menu'));
        document.getElementById('fit-toggle').addEventListener('click', () => toggleDropdown('fit-menu'));
        document.getElementById('stats-toggle').addEventListener('click', () => {
            const statsPanel = document.getElementById('stats-panel');
            statsPanel.classList.toggle('open');
            statsPanel.style.display = statsPanel.classList.contains('open') ? 'block' : 'none';
            document.getElementById('stats-toggle').textContent = statsPanel.classList.contains('open') ? 'Hide Stats' : 'Show Stats';
        });

        document.getElementById('sidebar-toggle').addEventListener('click', toggleSidebar);
        document.getElementById('mobile-toggle').addEventListener('click', toggleMobileSidebar);
        document.getElementById('add-stats-to-chart')?.addEventListener('change', updateGraph);

        const startPicker = flatpickr("#start-date-input", {
            dateFormat: "m/d/Y",
            onChange: function(selectedDates) {
                startDate = selectedDates[0];
                document.getElementById('time-range-toggle').textContent = 
                    `${startDate ? startDate.toLocaleDateString() : 'Start'} - ${endDate ? endDate.toLocaleDateString() : 'End'}`;
                updateGraph();
            }
        });

        const endPicker = flatpickr("#end-date-input", {
            dateFormat: "m/d/Y",
            onChange: function(selectedDates) {
                endDate = selectedDates[0];
                document.getElementById('time-range-toggle').textContent = 
                    `${startDate ? startDate.toLocaleDateString() : 'Start'} - ${endDate ? endDate.toLocaleDateString() : 'End'}`;
                updateGraph();
            }
        });
    </script>
</body>
</html>