<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comparative Biospheromics</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #000000;
            font-family: 'Exo 2', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        h1 {
            color: #00FFFF;
            text-align: center;
            text-shadow: 0 0 10px #00FFFF;
            padding: 1vh;
            font-family: 'Orbitron', sans-serif;
            font-size: calc(16px + 2vw);
            margin: 0;
            flex-shrink: 0;
        }
        .control-bar {
            width: 100%;
            padding: 1vh 1vw;
            background-color: #1A1A1A;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
            box-sizing: border-box;
            gap: 15px;
            flex-shrink: 0;
        }
        .button-container {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 150px;
            max-width: 25%;
        }
        .button-label {
            color: #FFFF00;
            font-family: 'VT323', monospace;
            font-size: calc(10px + 0.5vw);
            margin-right: 10px;
            flex-shrink: 0;
        }
        select {
            background: #1A1A1A;
            border: 2px solid #00FFFF;
            border-radius: 5px;
            color: #00FFFF;
            font-family: 'Exo 2', sans-serif;
            font-size: 12px;
            padding: 5px;
            flex-grow: 1;
            box-shadow: 0 0 4px #00FFFF;
            cursor: pointer;
            outline: none;
            max-width: 100%;
        }
        select:hover {
            box-shadow: 0 0 6px #00FFFF;
        }
        option {
            color: #00FFFF;
        }
        option.inactive {
            color: rgba(0, 255, 255, 0.5);
        }
        .graph-container {
            width: 90%;
            flex-grow: 1;
            margin: 1vh auto;
            position: relative;
            background-color: #1A1A1A;
            overflow: hidden;
            min-height: 200px;
        }
        #graph {
            width: 100%;
            height: 100%;
        }
        #graph::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                to bottom,
                rgba(0, 255, 255, 0.06),
                rgba(0, 255, 255, 0.06) 2px,
                transparent 2px,
                transparent 4px
            );
            pointer-events: none;
            z-index: 10;
        }
        .data-link {
            text-align: center;
            padding: 0.5vh;
            background-color: #1A1A1A;
            flex-shrink: 0;
        }
        .data-link a {
            color: #00FFFF;
            font-family: 'VT323', monospace;
            font-size: calc(10px + 0.5vw);
            text-decoration: none;
        }
        .data-link a:hover {
            text-shadow: 0 0 5px #00FFFF;
        }
        @media (max-width: 768px) {
            .control-bar {
                flex-direction: column;
                align-items: flex-start;
                padding: 1vh 2vw;
            }
            .button-container {
                width: 100%;
                max-width: none;
                margin: 5px 0;
            }
            .button-label {
                width: 100px;
                text-align: right;
                margin-right: 10px;
            }
            select {
                width: calc(100% - 110px);
            }
        }
    </style>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
</head>
<body>
    <h1>Comparative Biospheromics</h1>
    <div class="control-bar">
        <div class="button-container">
            <span class="button-label">Ecotrons:</span>
            <select id="ecotron-selector" multiple>
                <!-- Populated dynamically -->
            </select>
        </div>
        <div class="button-container">
            <span class="button-label">Independent:</span>
            <select id="independent-selector">
                <option value="CO2_Level">CO2_Level</option>
                <option value="Temperature_Level">Temperature_Level</option>
                <option value="Fertilizer_Dose">Fertilizer_Dose</option>
                <option value="GMO_Presence">GMO_Presence</option>
                <option value="Vector_Presence">Vector_Presence</option>
            </select>
        </div>
        <div class="button-container">
            <span class="button-label">Dependent:</span>
            <select id="dependent-selector">
                <option value="Plant_Growth_Rate">Plant_Growth_Rate</option>
                <option value="Photosynthesis_Rate">Photosynthesis_Rate</option>
                <option value="Soil_Carbon_Content">Soil_Carbon_Content</option>
                <option value="Species_Composition">Species_Composition</option>
                <option value="Water_Use_Efficiency">Water_Use_Efficiency</option>
                <option value="Phenology">Phenology</option>
                <option value="Soil_Moisture_Content">Soil_Moisture_Content</option>
                <option value="Net_Primary_Productivity">Net_Primary_Productivity</option>
                <option value="Mortality_Rates">Mortality_Rates</option>
                <option value="Plant_Biomass">Plant_Biomass</option>
                <option value="Nutrient_Leaching">Nutrient_Leaching</option>
                <option value="Soil_Microbial_Activity">Soil_Microbial_Activity</option>
                <option value="Eutrophication_Levels">Eutrophication_Levels</option>
                <option value="Gene_Flow">Gene_Flow</option>
                <option value="Crop_Yield">Crop_Yield</option>
                <option value="Non_Target_Species_Effects">Non_Target_Species_Effects</option>
                <option value="Pest_Resistance">Pest_Resistance</option>
                <option value="Target_Population_Size">Target_Population_Size</option>
                <option value="Off_Target_Mutations">Off_Target_Mutations</option>
                <option value="Genetic_Diversity">Genetic_Diversity</option>
                <option value="Ecosystem_Trophic_Dynamics">Ecosystem_Trophic_Dynamics</option>
                <option value="Vector_Persistence">Vector_Persistence</option>
            </select>
        </div>
        <div class="button-container">
            <span class="button-label">View:</span>
            <select id="view-selector">
                <option value="scatter">Scatter Plot</option>
                <option value="bar">Bar Chart</option>
                <option value="gene_flow">Gene Flow Plot</option>
                <option value="mutation_heatmap">Mutation Heatmap</option>
                <option value="diversity_bar">Genetic Diversity Bar</option>
            </select>
        </div>
    </div>
    <div class="graph-container">
        <div id="graph"></div>
    </div>
    <div class="data-link">
        <a href="https://raw.githubusercontent.com/aime2solve/200earths/refs/heads/main/200earths.csv" target="_blank">View Data (200earths.csv)</a>
    </div>

    <script>
        console.log('Script started');

        const colors = {
            'Plant_Growth_Rate': '#00FFFF', 'Photosynthesis_Rate': '#FF00FF', 'Soil_Carbon_Content': '#00FF00',
            'Gene_Flow': '#0080FF', 'Off_Target_Mutations': '#80FF80', 'Genetic_Diversity': '#FF8080'
        };

        const units = {
            'CO2_Level': 'ppm', 'Temperature_Level': '°C', 'Fertilizer_Dose': 'kg/ha', 'GMO_Presence': 'binary', 'Vector_Presence': 'binary',
            'Plant_Growth_Rate': 'mm/day', 'Photosynthesis_Rate': 'µmol/m²s', 'Soil_Carbon_Content': '%', 'Gene_Flow': '%',
            'Off_Target_Mutations': '%', 'Genetic_Diversity': 'index'
        };

        const csvUrl = 'https://raw.githubusercontent.com/aime2solve/200earths/refs/heads/main/200earths.csv';
        let data = [];

        fetch(csvUrl)
            .then(response => {
                console.log('Fetch response status:', response.status);
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                return response.text();
            })
            .then(csvText => {
                console.log('CSV text received, length:', csvText.length);
                Papa.parse(csvText, {
                    header: true,
                    dynamicTyping: true,
                    complete: function(results) {
                        data = results.data.filter(row => row.Ecotron);
                        console.log('Parsed Data (first 5 rows):', data.slice(0, 5));
                        console.log('Data length:', data.length);
                        if (data.length === 0) {
                            console.error('No valid data parsed');
                            Plotly.newPlot('graph', [], layoutConfig('No data available'));
                            return;
                        }
                        populateEcotronSelector();
                        updateGraph();
                    },
                    error: function(error) {
                        console.error('Papa Parse Error:', error);
                        Plotly.newPlot('graph', [], layoutConfig('Error parsing CSV'));
                    }
                });
            })
            .catch(error => {
                console.error('Fetch Error:', error);
                Plotly.newPlot('graph', [], layoutConfig('Failed to load CSV'));
            });

        function populateEcotronSelector() {
            console.log('Populating Ecotron selector');
            const ecotrons = [...new Set(data.map(row => row.Ecotron))].filter(e => e);
            const selector = document.getElementById('ecotron-selector');
            selector.innerHTML = '';
            ecotrons.forEach(ecotron => {
                const option = document.createElement('option');
                option.value = ecotron;
                option.text = ecotron;
                option.selected = true;
                selector.appendChild(option);
            });
            console.log('Ecotron Options:', ecotrons);
        }

        function updateViewOptions() {
            console.log('Updating view options');
            const dependent = document.getElementById('dependent-selector').value;
            const viewOptions = document.getElementById('view-selector').options;

            Array.from(viewOptions).forEach(option => {
                const value = option.value;
                if (value === 'scatter' || value === 'bar') {
                    option.className = '';
                } else if (value === 'gene_flow') {
                    option.className = dependent === 'Gene_Flow' ? '' : 'inactive';
                } else if (value === 'mutation_heatmap') {
                    option.className = dependent === 'Off_Target_Mutations' ? '' : 'inactive';
                } else if (value === 'diversity_bar') {
                    option.className = dependent === 'Genetic_Diversity' ? '' : 'inactive';
                }
            });
        }

        function layoutConfig(title = 'Select Variables to Begin') {
            console.log('Generating layout with title:', title);
            return {
                plot_bgcolor: '#1A1A1A',
                paper_bgcolor: '#1A1A1A',
                font: {color: '#FFFFFF', family: 'Exo 2, sans-serif', size: 14},
                title: {
                    text: title,
                    font: {size: 24, color: '#00FFFF', family: 'VT323, monospace'},
                    x: 0.05,
                    xanchor: 'left',
                    y: 0.95,
                    yanchor: 'top'
                },
                xaxis: {gridcolor: '#333333', automargin: true},
                yaxis: {gridcolor: '#333333', automargin: true},
                legend: {
                    font: {color: '#00FF00', size: 12, family: 'VT323, monospace'},
                    x: 0.01,
                    y: 0.99,
                    xanchor: 'left',
                    yanchor: 'top',
                    bgcolor: '#1A1A1A',
                    bordercolor: '#00FFFF',
                    borderwidth: 1
                },
                margin: {l: 50, r: 50, t: 60, b: 50}
            };
        }

        function linearRegression(x, y) {
            console.log('Running linear regression with x:', x, 'y:', y);
            const n = x.length;
            if (n < 2) {
                console.warn('Not enough points for regression:', n);
                return { slope: NaN, intercept: NaN, r2: NaN };
            }
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.map((xi, i) => xi * y[i]).reduce((a, b) => a + b, 0);
            const sumXX = x.map(xi => xi * xi).reduce((a, b) => a + b, 0);
            const sumYY = y.map(yi => yi * yi).reduce((a, b) => a + b, 0);
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            const r2 = Math.pow((n * sumXY - sumX * sumY) / Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY)), 2);
            console.log('Regression result:', {slope, intercept, r2});
            return { slope, intercept, r2 };
        }

        function updateGraph() {
            console.log('Updating graph');
            const ecotrons = Array.from(document.getElementById('ecotron-selector').selectedOptions).map(opt => opt.value);
            const independent = document.getElementById('independent-selector').value;
            const dependent = document.getElementById('dependent-selector').value;
            const view = document.getElementById('view-selector').value;

            console.log('Selections:', {ecotrons, independent, dependent, view});

            if (!data.length || !ecotrons.length || !independent || !dependent) {
                console.log('Missing selections or data');
                Plotly.newPlot('graph', [], layoutConfig('No data or selections'));
                return;
            }

            const filteredData = data.filter(row => ecotrons.includes(row.Ecotron));
            console.log('Filtered Data (first 5 rows):', filteredData.slice(0, 5));
            let traces = [];
            let layout = layoutConfig(`${dependent} vs ${independent}`);

            if (view === 'scatter') {
                ecotrons.forEach(ecotron => {
                    const ecotronData = filteredData.filter(row => row.Ecotron === ecotron);
                    const x = ecotronData.map(row => row[independent] !== undefined ? parseFloat(row[independent]) : NaN).filter(v => !isNaN(v));
                    const y = ecotronData.map(row => row[dependent] !== undefined ? parseFloat(row[dependent]) : NaN).filter(v => !isNaN(v));
                    console.log(`Ecotron: ${ecotron}, X (${independent}):`, x, `Y (${dependent}):`, y);
                    if (x.length > 0 && y.length > 0) {
                        traces.push({
                            x: x,
                            y: y,
                            mode: 'markers',
                            name: ecotron,
                            marker: {size: 12, color: colors[dependent] || '#FFFFFF', line: {width: 2, color: '#FFFFFF'}}
                        });
                    }
                });

                const allX = filteredData.map(row => row[independent] !== undefined ? parseFloat(row[independent]) : NaN).filter(v => !isNaN(v));
                const allY = filteredData.map(row => row[dependent] !== undefined ? parseFloat(row[dependent]) : NaN).filter(v => !isNaN(v));
                console.log('Aggregate data for regression - X:', allX, 'Y:', allY);
                if (allX.length >= 2 && allX.length === allY.length) {
                    const { slope, intercept, r2 } = linearRegression(allX, allY);
                    if (!isNaN(slope) && !isNaN(intercept) && !isNaN(r2)) {
                        const xRange = [Math.min(...allX), Math.max(...allX)];
                        const yFit = xRange.map(xi => slope * xi + intercept);
                        console.log('Adding aggregate trendline: xRange:', xRange, 'yFit:', yFit);
                        traces.push({
                            x: xRange,
                            y: yFit,
                            mode: 'lines',
                            name: `Fit: y = ${slope.toFixed(2)}x + ${intercept.toFixed(2)}, R² = ${r2.toFixed(3)}`,
                            line: {color: '#FF00FF', width: 2}
                        });
                    } else {
                        console.warn('Aggregate regression failed:', {slope, intercept, r2});
                    }
                } else {
                    console.warn('Not enough points for aggregate regression:', allX.length);
                }

                layout.xaxis.title = `${independent} (${units[independent] || ''})`;
                layout.yaxis.title = `${dependent} (${units[dependent] || ''})`;
            } else if (view === 'bar') {
                const x = ecotrons;
                const y = ecotrons.map(ecotron => {
                    const ecotronData = filteredData.filter(row => row.Ecotron === ecotron);
                    const values = ecotronData.map(row => row[dependent] !== undefined ? parseFloat(row[dependent]) : NaN).filter(v => !isNaN(v));
                    return values.length ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                });
                console.log('Bar Chart Data:', {x, y});
                traces.push({
                    x: x,
                    y: y,
                    type: 'bar',
                    marker: {color: colors[dependent] || '#FFFFFF', line: {width: 2, color: '#FFFFFF'}}
                });
                layout.xaxis.title = 'Ecotron';
                layout.yaxis.title = `${dependent} (${units[dependent] || ''})`;
            } else if (view === 'gene_flow' && dependent === 'Gene_Flow') {
                const url = filteredData.find(row => row.Data_URL)?.Data_URL || '';
                if (url) {
                    Plotly.newPlot('graph', [], layoutConfig(`Gene Flow data at: ${url}`));
                    return;
                }
                ecotrons.forEach(ecotron => {
                    const ecotronData = filteredData.filter(row => row.Ecotron === ecotron);
                    const x = ecotronData.map(row => row[independent] !== undefined ? parseFloat(row[independent]) : NaN).filter(v => !isNaN(v));
                    const y = ecotronData.map(row => row[dependent] !== undefined ? parseFloat(row[dependent]) : NaN).filter(v => !isNaN(v));
                    if (x.length > 0 && y.length > 0) {
                        traces.push({
                            x: x,
                            y: y,
                            mode: 'lines+markers',
                            name: ecotron,
                            line: {color: colors[dependent], width: 2},
                            marker: {size: 8}
                        });
                    }
                });
                layout.xaxis.title = `${independent} (${units[independent] || ''})`;
                layout.yaxis.title = 'Gene Flow (%)';
            } else if (view === 'mutation_heatmap' && dependent === 'Off_Target_Mutations') {
                const url = filteredData.find(row => row.Data_URL)?.Data_URL || '';
                if (url) {
                    Plotly.newPlot('graph', [], layoutConfig(`Mutation data at: ${url}`));
                    return;
                }
                const z = ecotrons.map(ecotron => {
                    const ecotronData = filteredData.filter(row => row.Ecotron === ecotron);
                    return ecotronData.map(row => row[dependent] !== undefined ? parseFloat(row[dependent]) : 0);
                });
                traces.push({
                    z: z,
                    x: filteredData.map(row => row[independent]).slice(0, z[0].length),
                    y: ecotrons,
                    type: 'heatmap',
                    colorscale: 'Viridis'
                });
                layout.xaxis.title = `${independent} (${units[independent] || ''})`;
                layout.yaxis.title = 'Ecotron';
            } else if (view === 'diversity_bar' && dependent === 'Genetic_Diversity') {
                const url = filteredData.find(row => row.Data_URL)?.Data_URL || '';
                if (url) {
                    Plotly.newPlot('graph', [], layoutConfig(`Diversity data at: ${url}`));
                    return;
                }
                const x = ecotrons;
                const y = ecotrons.map(ecotron => {
                    const ecotronData = filteredData.filter(row => row.Ecotron === ecotron);
                    const values = ecotronData.map(row => row[dependent] !== undefined ? parseFloat(row[dependent]) : NaN).filter(v => !isNaN(v));
                    return values.length ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                });
                traces.push({
                    x: x,
                    y: y,
                    type: 'bar',
                    marker: {color: colors[dependent] || '#FFFFFF', line: {width: 2, color: '#FFFFFF'}}
                });
                layout.xaxis.title = 'Ecotron';
                layout.yaxis.title = 'Genetic Diversity (index)';
            } else {
                Plotly.newPlot('graph', [], layoutConfig('View not applicable'));
                return;
            }

            console.log('Final Traces:', traces);
            if (traces.length === 0) {
                console.error('No traces to plot');
                Plotly.newPlot('graph', [], layoutConfig('No valid data to plot'));
                return;
            }
            Plotly.newPlot('graph', traces, layout)
                .then(() => console.log('Plot rendered successfully'))
                .catch(err => console.error('Plotly Error:', err));
        }

        document.getElementById('ecotron-selector').addEventListener('change', () => { updateViewOptions(); updateGraph(); });
        document.getElementById('independent-selector').addEventListener('change', () => { updateViewOptions(); updateGraph(); });
        document.getElementById('dependent-selector').addEventListener('change', () => { updateViewOptions(); updateGraph(); });
        document.getElementById('view-selector').addEventListener('change', updateGraph);
    </script>
</body>
</html>